#==============================================================================
#==============================================================================
#====================== SAMPLES and DOCUMENTATION =============================
#==============================================================================
#==============================================================================

#----------------------------------------------------------
# the ini section names are specified according to 2 formats
# 1) [MODE]
# 2) [MODE SUBMODE]
# You use the check defined in a specific ini section by specifying 
# -m MODE or 
# -m MODE -s SUBMODE 
# on the plugin command line
# this helps us group similar checks together
# eg to run this minimal check which belongs the sample group
# -m sample -s minimal
[sample minimal]
# this help is displayed only when -m MODE or -m MODE -s SUBMODE are specified AND --inihelp is used on the command line
inihelp=<<EOT
Help for a sample check that specifies only a minimal amount of configuration in the ini File.
This sample simply displays the Name of the Operating System and Service Pack version.
It has no warning/critical specification and provides no performance data.
EOT

query=Select * From Win32_OperatingSystem

# the first display field is the standard one we use for the core plugin checks. It includes the status of the check and what triggered a warning/critical state (if any)
display=_DisplayMsg||~|~| - ||
display=Caption
display=CSDVersion||~|~|||


[sample uptime]
# this help is displayed only when -m MODE or -m MODE -s SUBMODE are specified AND --inihelp is used on the command line
inihelp=<<EOT
Help for a sample check that is similar to checkuptime. This one is somewhat simpler and uses seconds.
EOT

query=Select SystemUpTime,Frequency_Sys100NS,Timestamp_Object from Win32_PerfRawData_PerfOS_System

customfield=_UptimeSec,PERF_ELAPSED_TIME,SystemUpTime,%.1f

test=_UptimeSec

display=_DisplayMsg||~|~| - ||
display=_UptimeSec|sec|System Uptime is |~|.||

perf=_UptimeSec|sec|Uptime Seconds

#----------------------------------------------------------
# eg to run this full check which belongs the sample group
# -m sample -s full
[sample full]

# the version of the plugin that this section requires to operate
requires=1.41

# this help is displayed only when -m MODE or -m MODE -s SUBMODE are specified AND --inihelp is used on the command line
inihelp=<<EOT
Help for a sample check that specifies all currently possible fields in the ini File.
EOT

# Note:
# use the -d parameter to debug and see the query and the output returned from wmic 
# this helps build the correct query, get the test=, display= and perf= field names correct
# and shows you if you need to specify headerregex= and dataregex=

# The documentation for WMI for this query can be found at
# http://msdn.microsoft.com/en-us/library/aa394239%28v=VS.85%29.aspx
# Note that sometimes the field names returned by wmic sometime differ slightly to those listed by Microsoft
# Most of them are ok by some do vary (most in capitalisation)
# eg wmic returns "FileControlBytesPersec" but Microsoft lists FileControlBytesPerSec

# only use this field if the WMI query needs to have / converted to \
# useful to make the command line more friendly for the user since the use of \ on the command line can get tricky
slashconversion=1

# set the WMI namespace if it is not the default root/cimv2
# namespace=root/MicrosoftDNS

# the Name field sometimes gets returned in by wmic for most queries without being specified
# it seems to be OS version dependent. 
# We recommend always specifying if it in the the WMI Class it to make sure queries are OS version indpendent
# Sometimes the Name field contains | - see info on dataregex field to fix this if needed
# for some queries you might add some thing like "WHERE Name="{_arg1}"
# this will allow you to select a specific returned row when multiple are returned
# this sample does not use it but you will find others below that do
query=Select Name,FreePhysicalMemory,TotalVisibleMemorySize,RegisteredUser,ServicePackMajorVersion,NumberOfProcesses,WindowsDirectory,NumberOfUsers,MaxNumberOfProcesses From Win32_OperatingSystem

# create custom fields that can be used for display, perf data or testing warn/crit criteria
# for example you might want to average to readings of a WMI Raw counter
# the format of this field is
# NEWFIELDNAME,FUNCTION,FUNCTIONPARAMETERS
# where FUNCTIONPARAMETERS itself is a comma delimited list and specific to the FUNCTION
# we like to start our NEWFIELDNAMEs with an _ as you will see in the samples
# where we take 2 WMI values and calculate a percentage from them like this percentage=100* PARAM1/PARAM2
# we then apply the sprintf format string %.1f to give 1 decimal place
# we can then use the new field, _FreeMemPercent in test=, display= and perf= settings
# in this particular example we have
#           NEWFIELDNAME   FUNCTION PARAM1             PARAM2                 PARAM3
customfield=_FreeMemPercent,Percent,FreePhysicalMemory,TotalVisibleMemorySize,%.1f,

#======================================= customfield FUNCTIONS ====================================
# DOCUMENT ALL AVAILABLE customfield FUNCTIONs

# ----- Percent
   # it requires one completed WMI queries 
   # the parameters for this "function" are
   # SOURCEFIELD1,SOURCEFIELD2,SPRINTF_SPEC
   # where 
   # SOURCEFIELD1 [0] is some number
   # SOURCEFIELD2 [1] is some number
   # SPRINTF_SPEC [2] - a format specification passed directly to sprintf to format the result (can leave blank)
   # INVERT [3] take the resulting value away from this number. Useful in the following example eg set this value to 100 to show busy percentage where counter value is an idle percentage.
   # Formula is 100 * SOURCEFIELD1/SOURCEFIELD2
# ----- WMITimestampToAgeSec
   # it requires one completed WMI query
   # the parameters for this "function" are
   # SOURCEFIELD1
   # where 
   # SOURCEFIELD1 [0] is a WMI timestamp like 20100528105127.000000+600
   # This timestamp is a GMT time, we convert it to an age in seconds
# ----- SectoDay
   # converts a number of seconds to days
   # it requires one completed WMI query
   # the parameters for this "function" are
   # SOURCEFIELD1,SPRINTF_SPEC
   # where 
   # SOURCEFIELD1 [0] is a number of seconds
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
# ------ KBtoB
   # converts a number of kilo bytes to bytes - then we can use our standard scaling routine on the number for a niver display
   # BYTEFACTOR is used in this calculation
   # it requires one completed WMI query
   # the parameters for this "function" are
   # SOURCEFIELD1,SPRINTF_SPEC
   # where 
   # SOURCEFIELD1 [0] is a number of KB
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
   #

# these next function types actually directly related to the WMI raw data type. See the http references.
# References:
# http://include.wutils.com/wmi/ROOT%5Ccimv2/CIM_StatisticalInformation/Win32_Perf/Win32_PerfRawData/derived-classes.html
# http://msdn.microsoft.com/en-us/library/aa389383%28v=VS.85%29.aspx
# ----- PERF_COUNTER_RAWCOUNT - Counter Type #65536
   # Does not need any additional calculation - just use the value direct from WMI
# ----- PERF_100NSEC_TIMER_INV - CounterType #558957824
   # refer http://technet.microsoft.com/en-us/library/cc757283%28WS.10%29.aspx
   # this is a calculation like for checkcpu found on 
   # it requires two completed WMI queries (sample=2)
   # Formula = (1- (   (N2 - N1) / (D2 - D1) /F   )) x 100
   # we assume that the Timefield (D) we need is Timestamp_Sys100NS
   # 
   # the parameters for this "function" are
   # SOURCEFIELD,SPRINTF_SPEC,MAX
   # where 
   # SOURCEFIELD [0] is the WMI Field to base this on eg PercentProcessorTime - required
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
   # MAXIMUM VALUE [2] - the maximum value that this "function" will return (optional)
# ----- PERF_100NSEC_TIMER - CounterType #542180608
   # refer http://technet.microsoft.com/en-us/library/cc728274%28WS.10%29.aspx
   # it requires two completed WMI queries (sample=2)
   # (Nx - N0) / (Dx - D0) x 100
   # we assume that the Timefield (D) we need is Timestamp_Sys100NS
   # 
   # the parameters for this "function" are
   # SOURCEFIELD,SPRINTF_SPEC,MAX
   # where 
   # SOURCEFIELD [0] is the WMI Field to base this on eg PercentProcessorTime - required
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
   # MAXIMUM VALUE [2] - the maximum value that this "function" will return (optional)
# ----- PERF_COUNTER_COUNTER and PERF_COUNTER_BULK_COUNT  - CounterType #272696320 and #272696576
   # refer http://technet.microsoft.com/en-us/library/cc740048%28WS.10%29.aspx
   # it requires two completed WMI queries (sample=2)
   # Formula = (Nx - N0) / ((Dx - D0) / F)
   # we assume that the Timefield (D) we need is Timestamp_Sys100NS
   # we assume that the Frequency (F) we need is Frequency_Sys100NS
   # 
   # the parameters for this "function" are
   # SOURCEFIELD,SPRINTF_SPEC
   # where 
   # SOURCEFIELD [0] is the WMI Field to base this on eg PercentProcessorTime - required
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
# ----- PERF_PRECISION_100NS_TIMER and PERF_COUNTER_100NS_QUEUELEN_TYPE   - CounterType #542573824 and #5571840
   # refer http://technet.microsoft.com/en-us/library/cc756128%28WS.10%29.aspx
   # it requires two completed WMI queries (sample=2)
   # Formula = N1 - N0 / D1 - D0
   # we assume that the Timefield (D) we need is Timestamp_Sys100NS
   #
   # REfer http://technet.microsoft.com/en-us/library/cc781696%28WS.10%29.aspx for PERF_COUNTER_100NS_QUEUELEN_TYPE
   # This one seems to give correct results calculated like this but has a slightly different formula on the reference page?
   # 
   # the parameters for this "function" are
   # SOURCEFIELD,MULTIPLIER,SPRINTF_SPEC
   # where 
   # SOURCEFIELD [0] is the WMI Field to base this on eg PercentProcessorTime - required
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
   # MULTIPLIER [2] is a multiplier useful to make the fraction a percentage eg 100
   # INVERT [3] take the value away from this number. Useful in the following example eg set this value to 100 to show busy percentage where counter value is an idle percentage. Applied after the multiplier
# ----- PERF_ELAPSED_TIME - CounterType #807666944
   # refer http://technet.microsoft.com/en-us/library/cc756820%28WS.10%29.aspx
   # it requires two completed WMI queries (sample=2)
   # Formula = (D0 - N0) / F
   # we assume that the Timefield (D) we need is Timestamp_Object
   # we assume that the Frequency (F) we need is Frequency_Sys100NS
   # 
   # the parameters for this "function" are
   # SOURCEFIELD,SPRINTF_SPEC
   # where 
   # SOURCEFIELD [0] is the WMI Field to base this on eg PercentProcessorTime - required
   # SPRINTF_SPEC [1] - a format specification passed directly to sprintf to format the result (can leave blank)
   #
#====================================== END customfield FUNCTIONS =================================

# list the fields that we want to be able to specify warning/critical values against
# the first one defined is the default if none is specified in a warn/crit specification on the command line
# if processing multi-row WMI output then this is run against each row (unless processallrows=0 is set)
test=NumberOfProcesses
test=NumberOfUsers
test=_FreeMemPercent

# list the fields that are displayed in the plugin output
# fields displayed in the order that they are defined and at least one is always required
# the value can be in 3 formats - 
# 1) FIELD (where we just display this field like FIELD=xx,
# 2) FIELD|UNITS (where we just display this field like FIELD=xxUNITS,
# 3) FIELD|UNITS|DISPLAY|SEP|DELIM|START|END
# where we display this FIELD like STARTDISPLAYSEPxxUNITSENDDELIM
# the default DELIM is comma space, if DELIM is set to ~ then none will be used
# the default SEP is =, if SEP is set to ~ then none will be used
# DISPLAY normally shows FIELD or whatever you specify as DISPLAY. Set DISPLAY to ~ to show nothing.
# if units is prefixed with # then we use a function to convert it to a scaled based figure using prefixes like K, M, G etc - the calculation is influenced by the BYTEFACTOR setting
# In DISPLAY/START/END anything enclosed in {} will be substituted by the value of that item of that name eg {DeviceID} will replace by the value contained in DeviceID eg C:
# eg BytesSentPersec will be shown as BytesSentPersec=XX, 
# eg BytesSentPersec|BYTES will be shown as BytesSentPersec=XXBytes, 
# eg _Used%|%|.|.||(|) will be shown as (45.2%)
# There are the following predefined fields -
# _StatusType - shows the status of the check eg OK, Warning etc
# _Triggers - shows which FIELDS triggered a warn/critical state
# _DisplayMsg - is _StatusType combined with _Triggers. We use this one all the time.
# _ChecksOK = the number of WMI checks that completed OK
# _ItemCount = the number of data rows returned by the WMI query
# if processing multi-row WMI output then this is run against each row (unless processallrows=0 is set)
display=_DisplayMsg||~|~| - ||
display=Name||OS| is |||
display=ServicePackMajorVersion||ServicePack| | ||
display=WindowsDirectory||Installed in| |. |(|)
display=_FreeMemPercent|%
display=NumberOfProcesses
display=MaxNumberOfProcesses|#
display=NumberOfUsers

# list of fields that are shown before each row of WMI data is displayed
# useful only for checks where you are processing multiple rows of data
# good for showing a heading/title/check introduction text that you do not want to show per row of data
# same format/rules as for display=
# see checkeachcpu section for an example
predisplay=

# list the fields to be included in performance data
# the value can be in 2 formats - 
# 1) FIELD
# 2) FIELD|UNITS
# 3) FIELD|UNITS|DISPLAY
# In DISPLAY/UNITS anything enclosed in {} will be substituted by the value of that item of that name eg {DeviceID} will replace by the value contained in DeviceID eg C:
# if processing multi-row WMI output then this is run against each row (unless processallrows=0 is set)
perf=NumberOfProcesses
# this next perf specification show how we can substitute data returned in the query into the display string of the performance data - sort of meaningless in this case but still shows how it can be done
perf=NumberOfUsers|users|User Count (Registered User={RegisteredUser})
perf=_FreeMemPercent|%
# If the check you are using can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} (or some other unique identifier - depends what is returned in your query) so that performance data is unique to each instance
# eg perf=TotalPagesPrinted||{Name} TotalPagesPrinted


# set this field to 0 to use it
# do not process all individual WMI data rows for warning/critical/display/perfdata
# if you want to process all rows returned in the WMI data leave this setting out or set to non-zero
# useful where you might be calculating all custom fields or only counting the rows
# or where you are using the createlist= setting to list the data
# see [checkproc memory] for an example
processallrows=0

# You only need this setting if you get WMI headeing fields that contain the delimiter "|".
# You probably don't ever need this, but it is available just in case
# Say the header comes back something like this:
# FreePhysicalMemory|MaxNumberOfProcesses|Name|NumberOfProcesses|NumberOfUsers|RegisteredUser|ServicePackMajorVersion|TotalVisibleMemorySize|WindowsDirectory
# All good - field names separated by |
# Notice how the Name field has been added by wmic and the fields are returned sorted in alphabetical order
# no need for a customer headerregex. This will be the case most of the time.
# If you ever need to use this refer to the comments on dataregex= as it works in the same way
headerregex=

# You only need this setting if you get WMI fields that contain the delimiter "|" - unfortunately this does happen
# Say the query comes back something like this:
#    1        2                     3                      4                   5              6  7    8     9    10      11
# 288976|4294967295|Microsoft Windows XP Professional|C:\WINDOWS|\Device\Harddisk0\Partition1|55|2|EveryOne|3|1228272|C:\WINDOWS
# Note that the Name field contains "Microsoft Windows XP Professional|C:\WINDOWS|\Device\Harddisk0\Partition1"
# This wrecks our standard field detection since there are now additional delimiters "|" in the data
# There are 2 ways to fix this - the easy way and the regular expression way
# 
# First the easy way - simply specify which fields you want to keep by listing the field numbers
# Field Numbers start at 1 and use a comma delimiter list
# So in the above example there are 9 fields delimited by |
# We don't want 4 and 5 (so we don't list them below)
dataregex=1,2,3,6,7,8,9,10,11

# If it is more complex than this (and yes this does happen eg event log queries) for example where \n is contained within the data itself
# then we have to specify our own custom regular expression to properly parse the data so that we can correctly recognise the columns
# the regex must entirely match the whole data row. We only collect a maximum of 9 fields for now with a custom regex
# the regex should end with \n since this marks the end of the line as returned by wmic
# the regex equivalent to the comma delimited list above is as follows:
# Field Num: 1      2      3     4     5    6     7      8     9        10    11 
#                               SKIP SKIP <--- regex skips the fields directly below "SKIP" but retrieves the others
#dataregex=(.*?)\|(.*?)\|(.*?)\|.*?\|.*?\|(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)\n
# it collects field 1,2,3 skips 4 and 5, and collects 6,7,8,9,10,11
# most of the time you will not need to specify a dataregex
# the regex above collects 9 fields out of what looks like 11 in the returned data
# if you need to you would normally just a regex just like it with more or less of the 
# (.*?) parts and delimiters \|
# eg row recognition when you want field1, field2, field4 and  NOT field3 would look like this
# dataregex=(.*?)\|(.*?)\|.*?\|(.*?)\n
# Note the use of .*? to match the 3rd field without () so that it does not become a field we capture
# If you get this regex wrong you will be unable to correctly identify returned data from the WMI query

# number of times to run the WMI query
# if you are using RAW performance data, you probably want 2 samples to get a complete plugin result
# here's the tricky part -
# even if you plan on using the keepstate feature (on by default) and you need 2 samples to get a complete plugin result
# you might be tempted to think that you only need one WMI query per plugin run (which is what actually occurs)
# but since you need 2 samples to do the calculations you still set samples=2
samples=1

# number of seconds delay between each WMI query
# ignored if keepstate is set, but you might want to set it incase you decide to turn keepstate off at some point
delay=1

# NOTE on Variable Substitution Using {}
# Command line parameters available for substitution using {} into query=, display= and perf= ini settings:
# _arg1, _arg2, _arg3, _arg4, _arg5, _bytefactor, _delay, _host, _timeout
# Each of the above matches the appropriate command line argument

# Special values available for substitution using {} into display= and perf= ini settings:
# _ChecksOK = the number of WMI checks that completed OK
# _ItemCount = the number of data rows returned by the WMI query

# WMI field names to provide calculated data (eg sums) for - not really used in the ini file for now
calc=
# If you specify the names of WMI fields in the calc= settings then there are some extra fields available
# for substitution into display= and perf= settings
# For example if you have a WMI field returned called "Size" and you want to add them all together and provide as performance data,
# then you specify calc=Size and then the following variable become available for substitution
# {_ColSum_Size} and {_QuerySum_Size}
# You could then stick perf=_ColSum_Size and it will provide "_ColSum_Size" as performance data
# Let me try and explain what these are ......
# Variables like "_QuerySum_FIELD" - sums up all the FIELD across all the queries for each Row Number. We use it internally to help us for checkcpuq
# Variables like "_ColSum_FIELD" sum up all the FIELDs (columns) within a single query - ie where multiple rows are returned
#  - you might use this for say, adding up total disk space. The WMI query for getting drive space can return info for all drives in a system
#     This is returned as the "Size" field out of WMI. If you have multiple drives you get multiple rows back in the WMI query and 
#     _ColSum_Size would be the total of all the Size fields in the query
#     We use this internally to help us with the checkdrivesize check

# create a list of fields that come back in the WMI Query
# FORMAT is createlist=NEWFIELDNAME|LINEDELIM|FIELDDELIM|UNIQUE|FIELD1,FIELD2,etc
# where  NEWFIELDNAME is the new field name to create eg _Processlist
#        LINEDELIM is the delimiter to place when reaching the end of a WMI Query row
#        FIELDDELIM is the delimiter to place between WMI fields on the same row
#        UNIQUE is set to 1 to only show unique items, set to 0 to show all items
createlist=
# normally this is most usefull when multiple rows are returned from a WMI query eg a list of processes
# there is a good example of this being used in the [checkproc memory] section to create a list of process names with PIDs
# eg createlist=_ProcessList|),   | (PID=|1|Name,IDProcess

# this setting allows you to disable the default behaviour of keeping state between plugin runs
# keepstate is only used if enabled and multiple WMI queries are performed
# a check like checkcpuq does not want to keep state between runs but performs multiple WMI queries, so it disables keepstate
# since the plugin default is to operate with keepstate enabled, specifying keepstate=1 does nothing
keepstate=0


#----------------------------------------------------------
[test 1]
# this help is displayed only when -m MODE or -m MODE -s SUBMODE are specified AND --inihelp is used on the command line
inihelp=<<EOT
Just for testing
EOT

query=select PercentProcessorTime,Timestamp_Sys100NS from Win32_PerfRawData_PerfOS_Processor

# run 2 WMI queries, 5 seconds apart. The delay only applies if using --nokeepstate
samples=2
delay=5

customfield=_AvgCPU,PERF_100NSEC_TIMER_INV,PercentProcessorTime,%.1f

test=_AvgCPU

# fields to display before we list out all the CPU data
predisplay=_DisplayMsg||~|~| - ||
#predisplay=_delay| sec|~|~|~|Average Utilisation (Over approx | period): 

# fields shown per cpu
display=_AvgCPU|%|CPU{Name}||||   

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_AvgCPU|%|Avg Utilisation CPU{Name}

#----------------------------------------------------------
[test 2]
# this help is displayed only when -m MODE or -m MODE -s SUBMODE are specified AND --inihelp is used on the command line
inihelp=<<EOT
Just for testing
EOT

query=select PercentProcessorTime,Timestamp_Sys100NS from Win32_PerfRawData_PerfOS_Processor

# run 2 WMI queries, 5 seconds apart. The delay only applies if using --nokeepstate
samples=2
delay=5

customfield=_AvgCPU,PERF_100NSEC_TIMER_INV,PercentProcessorTime,%.1f
customfield=_NoCPU,PERF_100NSEC_TIMER_INV,NoCPU,%.1f

test=_AvgCPU
test=_NoCPU
test=NoSuchField

# fields to display before we list out all the CPU data
predisplay=_DisplayMsg||~|~| - ||
#predisplay=_delay| sec|~|~|~|Average Utilisation (Over approx | period): 

# fields shown per cpu
display=_AvgCPU|%|CPU{Name}||||   
display=_NoCPU|%|CPU{Name}||||   
display=NoSuchField

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_AvgCPU|%|Avg Utilisation CPU{Name}
perf=_NoCPU|%|Avg Utilisation CPU{Name}
perf=NoSuchField